% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/factor_encoder.R
\name{factor.encoder}
\alias{factor.encoder}
\alias{factor.frame}
\title{Encoder for Qualitative Variables}
\usage{
factor.encoder(
  x,
  k = NULL,
  lump = c("none", "auto", "rank", "order"),
  others = "others",
  sep = ">",
  weights = NULL,
  frame = NULL,
  tag = "x"
)

factor.frame(levels, others = NULL, map = NULL, original = NULL, tag = "x")
}
\arguments{
\item{x}{a vector to be encoded as a qualitative variable.}

\item{k}{an integer specifying the maximum number of distinct levels to retain (including the catch-all level). If not positive, all unique values of \code{x} are used.}

\item{lump}{a character string specifying the lumping strategy: \code{"none"}, no lumping is performed; \code{"rank"}, lumps levels based on frequency rank; \code{"order"} merges adjacent levels based on cumulative frequency to preserve order; and \code{"auto"} automatically selects \code{"order"} for ordered factors and \code{"rank"} for others.}

\item{others}{a character string for the catch-all level (used when \code{lump = "rank"}).}

\item{sep}{a character string used to separate the start and end levels when merging ordered factors (e.g., "Level1..Level3").}

\item{weights}{an optional numeric vector of sample weights for \code{x}.}

\item{frame}{a "factor.frame" object or a character vector that explicitly defines the levels of the variable.}

\item{tag}{the name of the variable.}

\item{levels}{a vector to be used as the levels of the variable.}

\item{map}{a named vector that maps original levels to lumped levels.}

\item{original}{a character vector to be used as the original levels for expanding the frame. Defaults to \code{NULL}.}
}
\value{
\code{factor.encoder()} returns an object of class "encoder". This is a list containing the following components:
\item{frame}{a "factor.frame" object containing the encoding information (levels).}
\item{n}{the number of encoding levels (i.e., columns in the design matrix).}
\item{type}{a character string describing the encoding type: "factor" or "null".}
\item{envir}{an environment for the \code{transform} and \code{encode} functions.}
\item{transform}{a function \code{transform(x, lumped = TRUE, ...)} that converts a vector into a factor with the encoded levels.}
\item{encode}{a function \code{encode(x, ...)} that converts a vector into the one-hot encoded matrix.}

\code{factor.frame()} returns a "factor.frame" object containing the encoding information.
}
\description{
\code{factor.encoder()} creates an encoder function for a qualitative (factor or character) variable.
This encoder converts the variable into a one-hot encoded (dummy) design matrix.

\code{factor.frame()} is a helper function to create a "factor.frame" object that defines the encoding scheme.
}
\details{
This function is designed to handle qualitative data for use in the MID model's linear system formulation.

The primary mechanism is one-hot encoding.
Each unique level of the input variable becomes a column in the output matrix.
For a given observation, the column corresponding to its level is assigned a \code{1}, and all other columns are assigned \code{0}.

When a variable has many unique levels (high cardinality), you can use the \code{lump} and \code{k} arguments to reduce dimensionality.
This is crucial for preventing MID models from becoming overly complex.
}
\examples{
# Create an encoder for a qualitative variable
data(iris, package = "datasets")
enc <- factor.encoder(x = iris$Species, lump = "none", tag = "Species")
enc

# Encode a vector with NA
enc$encode(iris$Species[c(50, 100, 150)])

# Lumping by rank (retain top k - 1 levels and others)
enc <- factor.encoder(x = iris$Species, k = 2, lump = "rank")
enc$encode(iris$Species[c(50, 100, 150)])

# Lumping by order (merge adjacent levels)
enc <- factor.encoder(x = iris$Species, k = 2, lump = "order")
enc$encode(iris$Species[c(50, 100, 150)])
}
\seealso{
\code{\link{numeric.encoder}}
}

---
title: "Getting Started with Color Themes"
description: >
  Provides a gallery of color themes implemented in the midr package.
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.height = 2.2,
  fig.width = 6
)

pkgs <- c("khroma", "viridisLite", "RColorBrewer", "gridExtra", "ggplot2", "DT", "htmltools")
install.packages(pkgs[!pkgs %in% list.files(.libPaths())])

show_colors_html <- function(colors, height = "25px") {
  div_tags <- lapply(colors, function(color) {
    htmltools::tags$div(
      style = paste("background-color:", color, ";",
                    "width: 100%; height:", height, ";",
                    "display: inline-block;")
    )
  })
  htmltools::tagList(htmltools::tags$div(
      style = "display: flex; width: 100%;", div_tags
  ))
}
```

# Color themes

The "color.theme" object provides two color-generating functions: `palette()` and `ramp()`. The `palette()` function accepts an integer $n$ and returns a vector of $n$ discrete colors. It is primarily intended for **qualitative** themes, where distinct colors are used to represent categorical data. The `ramp()` function accepts a numeric vector $x$ with values in the $[0, 1]$ interval and returns a vector of corresponding colors. It maps numeric values onto a continuous color gradient, making it suitable for **sequential** and **diverging** themes.

## Pre-defined themes

You can get a pre-defined "color.theme" object by providing a theme name to the `color.theme()` or `get.color.theme()` functions.

```{r, fig.height = 1.2, fig.width = 6, echo = c(-3, -4)}
library(midr)
library(ggplot2)
theme_set(theme_midr())
par.midr()
library(gridExtra)
# diverging color theme "nightfall" (package:khroma)
nightfall <- color.theme("nightfall")
print(nightfall)
```

```{r, fig.height = 0.35, fig.width = 6, echo = c(-1, -3, -5)}
par.midr(mar = c(0, 1, 0, 1))
nightfall$palette(5)
show_colors_html(nightfall$palette(5))
nightfall$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00))
show_colors_html(nightfall$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00)))
```

```{r, fig.height = 1.2, fig.width = 6, echo = c(-1)}
par.midr()
# sequential color theme "viridis" (package:viridisLite)
viridis <- color.theme("viridis")
print(viridis)
```

```{r, fig.height = 0.35, fig.width = 6, echo = c(-1, -3, -5)}
par.midr(mar = c(0, 1, 0, 1))
nightfall$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00))
show_colors_html(viridis$palette(5))
viridis$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00))
show_colors_html(viridis$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00)))
```

You can modify themes by **reversing** the color order or **changing** the theme type (e.g., from sequential to qualitative). These changes can be applied in two ways:

1.  **Using Arguments** : provide the appropriate argument to the function, such as `reverse = TRUE` or `type = "qualitative"`.
2.  **Using Suffixes** : for convenience, you can append a suffix directly to the theme's name. `_r` to reverse the theme, `@q` (or longer, such as `@qual`) to make the theme qualitative (`@d` for diverging, `@s` for sequential).

```{r, fig.height = 1.2, fig.width = 6, echo = c(-1)}
par.midr()
plot(color.theme("nightfall", reverse = TRUE),
     text = "khroma/nightfall_r")
plot(color.theme("nightfall", type = "qualitative"),
     text = "khroma/nightfall@qual")
plot(color.theme("viridis_r",),
     text = "viridisLite/viridis_r")
plot(color.theme("viridis@qual"),
     text = "viridisLite/viridis@qual")
```

When multiple packages provide a theme with the same name (e.g., "Paired"), you must specify which one to use. You can do this in two ways:

1.  **Using Argument** : provide the package name to the `source` argument (e.g., `source = "grDevices"`).
2.  **Using Prefix** : append a prefix to the theme name with the package name and a forward slash (e.g., `"RColorBrewer/Paired"`).

```{r, fig.height = 1.2, fig.width = 6, echo = c(-1)}
par.midr()
# qualitative color theme "Paired" (package:grDevices)
paired <- color.theme("Paired", source = "grDevices")
plot(paired, text = "grDevices/Paired")
# qualitative color theme "Paired" (package:RColorBrewer)
paired2 <- color.theme("RColorBrewer/Paired")
plot(paired2, text = "RColorBrewer/Paired")
```

## Custom themes

Alternatively, you can create a new "color.theme" object by passing a custom color vector or function to the first argument of `color.theme()` or `make.color.theme()`.

```{r, fig.height = 1.2, fig.width = 6, echo = -1}
par.midr()
# create new color theme using a color vector
mytheme <- color.theme(
  c("#003f5c", "#7a5195", "#ef5675", "#ffa600"),
  type = "sequential", name = "mytheme"
)
print(mytheme)
```

```{r, fig.height = 0.35, fig.width = 6, echo = c(-1, -3, -5)}
par.midr(mar = c(0, 1, 0, 1))
mytheme$palette(5)
show_colors_html(mytheme$palette(5))
mytheme$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00))
show_colors_html(mytheme$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00)))
```

```{r, fig.height = 1.2, fig.width = 6, echo = -1}
par.midr()
# create new color theme using a color function
rainbow <- color.theme(grDevices::rainbow,
                       name = "rainbow", source = "grDevices")
print(rainbow)
```

```{r, fig.height = 0.35, fig.width = 6, echo = c(-1, -3, -5)}
par.midr(mar = c(0, 1, 0, 1))
rainbow$palette(5)
show_colors_html(rainbow$palette(5))
rainbow$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00))
show_colors_html(rainbow$ramp(c(0.00, 0.25, 0.50, 0.75, 1.00)))
```

You can register a custom theme to call it by name later in you current R session. To do so, use the `set.color.theme()` function.

```{r, fig.height = 1.2, fig.width = 6, echo = -1}
par.midr()
set.color.theme(mytheme, name = "mytheme", source = "custom")
color.theme("mytheme_r@div")
color.theme("custom/mytheme@q")
```

## Using themes in **midr**

The color appearance of visualizations created with **midr** can be easily customized by passing a "color.theme" object or a pre-defined color theme name (see below) to `ggmid()` or `plot()`.

```{r, fig.weight = 6, fig.height = 4}
set.seed(42)
dataset <- diamonds[sample(nrow(diamonds), 5000L), ]
mid <- interpret(price ~ (carat + color + clarity + cut) ^ 2, dataset)
grid.arrange(
  ggmid(mid, "color:clarity", main.effect = TRUE),
  ggmid(mid, "color:clarity", main.effect = TRUE, theme = mytheme),
  ggmid(mid, "carat:color", main.effect = TRUE, theme = "tokyo_r"),
  ggmid(mid, "carat:color", main.effect = TRUE, theme = "bicolor")
)
imp <- mid.importance(mid)
grid.arrange(
  ggmid(imp, "heatmap"),
  ggmid(imp, "barplot", max = 10, theme = "mytheme@q"),
  ggmid(imp, "heatmap", theme = "mytheme_r"),
  ggmid(imp, "barplot", max = 10, theme = "highlight_r")
)
```

## Using themes with **ggplot2**

To apply your color themes to `ggplot2` plots, use the `scale_color_theme()` and `scale_fill_theme()` functions. These scales integrate your themes directly into the plot's `color` and `fill` aesthetics.

```{r, fig.weight = 6, fig.height = 4}
p <- ggplot(dataset) + geom_point(aes(carat, price, col = color))
grid.arrange(
  p + scale_color_theme("discreterainbow"),
  p + scale_color_theme("viridisLite/mako", discrete = TRUE),
  p + scale_color_theme("tokyo@qual"),
  p + scale_color_theme("highlight?base='#50505010'&which=6:7")
)
```

```{r, fig.weight = 6, fig.height = 4}
p <- ggplot(dataset) +
  geom_histogram(aes(x = carat, fill = cut), bins = 20)
grid.arrange(
  p + scale_fill_theme("muted_r"),
  p + scale_fill_theme("khroma/discreterainbow"),
  p + scale_fill_theme("mytheme@q"),
  p + scale_fill_theme("highlight?which=1:3&accent='maroon'")
)
```

```{r}
remove(mytheme, envir = midr:::kernel.env)
```

# Pre-defined color themes

The following color themes are available when the **midr** package is loaded. Some themes depend on other packages being installed, so for full functionality, please ensure you have already installed the **viridisLite**, **RColorBrewer**, and **khroma** packages.

```{r sequential, echo = -2}
.df <- color.theme.info()
DT::datatable(
  .df,
  class = 'cell-border stripe hover',
  rownames = FALSE,
  options = list(
    pageLength = 10,
    lengthMenu = c(10, 20, 50, 100),
    dom = 'Btip'
  )
)
```

## Diverging Color Themes

```{r, echo = FALSE}
par.midr(mfrow = c(2, 2))
df <- .df[.df$type == "diverging", ]
for (i in seq_len(nrow(df))) {
  ct <- color.theme(df[i, 1L], source = df[i, 2L])
  text <- sprintf("%s/%s", df[i, 2L], df[i, 1L])
  plot(ct, text = text)
}
```

## Qualitative Color Themes

```{r, echo = FALSE}
par.midr(mfrow = c(2, 2))
df <- .df[.df$type == "qualitative", ]
for (i in seq_len(nrow(df))) {
  ct <- color.theme(df[i, 1L], source = df[i, 2L])
  text <- sprintf("%s/%s", df[i, 2L], df[i, 1L])
  plot(ct, text = text)
}
```

## Sequential Color Themes

```{r, echo = FALSE}
par.midr(mfrow = c(2, 2))
df <- .df[.df$type == "sequential", ]
for (i in seq_len(nrow(df))) {
  ct <- color.theme(df[i, 1L], source = df[i, 2L])
  text <- sprintf("%s/%s", df[i, 2L], df[i, 1L])
  plot(ct, text = text)
}
```
